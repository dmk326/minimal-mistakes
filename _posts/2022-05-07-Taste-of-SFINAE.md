---
title: "Taste of SFINAE!"
categories:
  - C++
tags:
  - C++
  - Templates
  - MetaProgramming
  - SFINAE
---

# **Substitution Failure Is Not An Error --- SFINAE**

In the world of template meta-programming, we have the power to do a lot. Let’s take a small example,
say we want to perform “+” operation on two values, without templates metaprogramming we would probably write the following overloads for all types ourselves something like:

```
int add(int value1,  int value2)  {
    return value1 + value2;
}
// ------------------------------------------------------------------------
float add(float value1,  float value2)  {
    return value1 + value2;
} 
```

But as we know with templates we could simply write:

```
template<typename T>
T add(const T value1,  const T value2)  {
    return value1 + value2;
}

int main()  {
    add(1,2);
    add(2.4,3.5);
}
```

Now this template method `add` can be called for types T which support `operator +`. Hence when we call `add` with `int` types an int supporting overload of function add is autogenerated for us by the compiler and similarly for float, double, etc. depending upon the calls we make to template function `add`. <sup>(2)</sup>
Let's say we want to limit calls to our function add only for Float types, this is where SFINAE will come into the picture for us. We modify our template function a bit by using `enable_if_t` from the std library like this:

```
template<typename T>
std::enable_if_t<std::is_floating_point<T>::value,T>
add(const T value1,  const T value2)  {
     //do something specific to float types
     return value1 + value2;
}

int main()  {
    add(1,1);
    add(2.4,3.5);
}
```

What we are doing here is that:
`enable_if_t` will return a type based on the condition satisfied with `is_floating_pont<T>::value`. That means we want to enable the function only if the specified condition is satisfied, which here is that **T should be of type floating_point**.

Hence now if we compile and call with `add(1,2)` i.e. with integer types we will get the following error: **_template argument deduction/substitution failed" because there is no possible function to be called with ```add(int, int)```_**.

```
**<source>:14:12:**  **error: **no matching function for call to '**add(int, int)**'
**<source>:9:3:**  **note: **candidate: '**template<class T, class> T add(T, T)**'
T **add**(const T value1, const T value2) {
**<source>:9:3:**  **note: **  template argument deduction/substitution failed:
/opt/compiler-explorer/gcc-10.2.0/include/c++/10.2.0/type_traits: In substitution of '**template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]**'
```

One could argue here that substitution failure is an error in this case but that's just because there is no other viable function in this case which can be called".
Since we restricted the above method to just float types, hence the compiler fails to find any viable method for integer types. So, let's go ahead and provide it:

```
template<typename T>
std::enable_if_t<std::is_floating_point<T>::value,T>
add(const T value1,  const T value2)  {
     //do something specific to float types
     return value1 + value2;
}

template<typename T>
std::enable_if_t<!std::is_floating_point<T>::value,T>
add(const T value1,  const T value2)  {
     //non floating point types
     return value1 + value2;
}

int main()  {
    add(1,1);
    add(2.4,3.5);
}
```

Now the program will compile just fine.

What's happening here is that for the call `add(1,2)` compiler tries to call the first declaration of function i.e. for floating-point types but since that condition is not matched there is substitution failure but it was not an error as the compiler then tries to find any other viable functions which it can call and it can find that successfully for the second declaration of add which is for non-floating point types.

In simpler terms compiler tries to perform a name lookup and for function templates the template argument values are deduced from the types of the actual arguments passed. Then all occurrences of the template parameter are substituted with those deduced types. When this process leads to an invalid type (like integer types for the floating_point type method) the particular function is removed from the overload resolution set and the compiler moves on to look for another function in the overload set without throwing an error unless no other function is found in the overload set for this substitution. This is what we call [**SFINAE**](https://en.cppreference.com/w/cpp/language/sfinae){:target="_blank"}.

As stated in cpp reference [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae){:target="_blank"}: "_This rule applies during overload resolution of function templates: When [substituting](https://en.cppreference.com/w/cpp/language/function_template#Template_argument_substitution "cpp/language/function template"){:target="_blank"} the explicitly specified or [deduced type](https://en.cppreference.com/w/cpp/language/template_argument_deduction "cpp/language/template argument deduction"){:target="_blank"} for the template parameter fails, the specialization is discarded from the [overload set](https://en.cppreference.com/w/cpp/language/overload_resolution "cpp/language/overload resolution"){:target="_blank"} instead of causing a compile error._"

Let's look at another example:

We have a base class that has a protected destructor and exposes a pure virtual release method which all its derived classes must implement.

```
class base {
protected:
    virtual ~base()  =  default;
public:
    virtual  void release()  =  0;
};
```

We have two classes, one which is derived from the base and has a private destructor along with a public release method to free resources and another class which does not inherit from the base and has a public destructor to release resources:

```
//derive from base. Has dtor private and implement release
class derived:  public base {
private:
    ~derived() override  =  default;
public:
derived()  =  default;
     void release()  override  {
        //free up resource and self
     }
};

//does not derive from base. public dtor
class non_derived {
public:
    non_derived()  =  default;
    ~non_derived()  =  default;
};
```

We also have a method free that takes in template arguments such that it can release/free the memory of pointer of type T.

```
template<typename T>
void free(T* ptr) {
     if(ptr)
        delete ptr;
}

int main()  {
    non_derived * nd_ptr =  new non_derived();
    base * d_ptr =  new derived();
    free(nd_ptr);
    free(d_ptr);
}
```
Above call in main ```free(nd_ptr)``` will succeed but the call ```free(d_ptr)``` will fail with the following error:

```
In instantiation of '**void free(T*) [with T = derived]**':
**<source>:57:15:** required from here
**<source>:48:9:**  **error: **'**derived::~derived()**' is private within this context 
**delete ptr**
```

This is because the destructor of all types derived from `class base` which has a private destructor and we cannot call `delete` on its pointer directly but rather need to call the `release` method for such pointers. Now we want to implement the method `free` in such a way that it can handle pointers of both types i.e., derived from the base as well as non-derived classes.

```
template<typename T>
std::enable_if_t<std::is_base_of<base, T>::value,
void> free(T* ptr) {
     if(ptr)
        ptr->release();
}

template<typename T>
std::enable_if_t<!std::is_base_of<base, T>::value,
void> free(T* ptr) {
     if(ptr)
        delete ptr;
}
```

This way like the floating_point example, SFINAE will come into the picture and the compiler will deduce the correct method to be called for each type without throwing an error.

The problem with SFINAE is that it is very easy to get confused about what's actually happening in the code if you already do not know and the errors are also not that exactly straightforward either. The syntax and declaration for SFINAE to work properly with templates can also be quite challenging at times and the level of complexity grows with the advancing code base.

Concepts covered in this blog post are in respect to C++14 but with C++20, the standard has rolled out many more exciting features like [**concepts** and **requires**](https://en.cppreference.com/w/cpp/language/constraints#Concepts){:target="_blank"} which would probably make it easier to work with templates and SFINAE. We shall cover these in near future, Stay tuned.    

**Thanks for Reading!\
DMK**


### References:
1. Great Talk by **Arthur O'Dwyer** on SFINAE, covering subject in details in this [video of CppCon](https://www.youtube.com/watch?v=ybaE9qlhHvw){:target="_blank"} 
2. The floating_point example is taken from this [YouTube Video by Jason Turner](https://www.youtube.com/watch?v=dR64GQb4AGo){:target="_blank"} 
3. Another good video on [YouTube Channel WolfSound](https://www.youtube.com/watch?v=mNxAqLVIaW0){:target="_blank"}
4. Good [Blog](https://www.cppstories.com/2016/02/notes-on-c-sfinae/){:target="_blank"} about **SFINAE**